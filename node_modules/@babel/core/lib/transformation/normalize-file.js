"use strict";

exports.__esModule = true;
exports.default = normalizeFile;

var _convertSourceMap = _interopRequireDefault(require("convert-source-map"));

var _babylon = require("babylon");

var _codeFrame = require("@babel/code-frame");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shebangRegex = /^#!.*/;

function normalizeFile(options, code, ast) {
  code = "" + (code || "");
  var shebang = null;
  var inputMap = null;

  if (options.inputSourceMap !== false) {
    inputMap = _convertSourceMap.default.fromSource(code);

    if (inputMap) {
      code = _convertSourceMap.default.removeComments(code);
    } else if (typeof options.inputSourceMap === "object") {
      inputMap = _convertSourceMap.default.fromObject(options.inputSourceMap);
    }
  }

  var shebangMatch = shebangRegex.exec(code);

  if (shebangMatch) {
    shebang = shebangMatch[0];
    code = code.replace(shebangRegex, "");
  }

  if (!ast) ast = parser(options, code);
  return {
    code: code,
    ast: ast,
    shebang: shebang,
    inputMap: inputMap
  };
}

function parser(options, code) {
  var parseCode = _babylon.parse;
  var parserOpts = options.parserOpts;

  if (parserOpts.parser) {
    parseCode = parserOpts.parser;
    parserOpts = Object.assign({}, parserOpts, {
      parser: {
        parse: function parse(source) {
          return (0, _babylon.parse)(source, parserOpts);
        }
      }
    });
  }

  try {
    return parseCode(code, parserOpts);
  } catch (err) {
    var loc = err.loc;

    if (loc) {
      err.loc = null;
      err.message = options.filename + ": " + err.message + "\n" + (0, _codeFrame.codeFrameColumns)(code, {
        start: {
          line: loc.line,
          column: loc.column + 1
        }
      }, options);
    }

    throw err;
  }
}